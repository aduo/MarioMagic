# 定点小数与进位机制

## 定点小数

小数在表示小的增量方面很有用。老游戏的CPU不支持小数运算，常用整数来模拟定点小数。

例如使用2个字节（16位，相当于C中的short）表示一个整数部分占8位，小数部分占8位的定点小数。使用它，0x0180表示1+128/256=1.5. 它的加减可以直接使用整数加减。要获得整数部分，可以用：

```java
n >> 8
```

如果n定义为带符号的整数（没有使用unsigned），那么C/C++/Java会使用带符号的右移。n在移位前是负数的话，右移后会被符号扩展，相当于对正数做了右移后加回了负号。（-1是个例外）

累加时，如果两变量的小数位数不同，需要先移位以对齐小数点。例如小数部分有12位的速度v，要累加到小数部分只有8位的位置x（这样舍去了v最后的4位小数的精度，但也是无奈）：

```java
x += v >> 4;
```

定点小数的小数点位置不可变，与之对应的是浮点小数。现代计算机已经可以较快地进行浮点运算，实现时可以直接把变量定义成float. 不建议使用double，你用不到它的高精度，但它的高精度使它运算起来更慢。

任天堂超级玛丽1中，玩家在屏幕上的位置就使用这种方法存储。只有整数部分用于绘图。小数部分用于积累。

## 进位机制

以十进制为例，进位机制指的是：

- 加法时，若某位的结果超过9，则产生一个进位（carry），加到左边一位，伴随着这一位的结果-10.
- 减法时，若某位不够减，则产生一个借位（borrow），从左边一位扣除，伴随着这一位结果+10

这是我们小学算术的内容，也是现代计算机CPU内部进行二进制加减法的原理。但它并不是算术系统的专利。借用这套机制我们可以实现其他有用的效果。

### 双定时器

即两个变量的定时器。子变量每数到0一次，主变量才减1。

子变量用于减缓主变量的递减速度，调整它的重装值可控制减缓的程度。

一个初值为M、子变量重装值为N的双定时器，总定时量与一个初值为M\*N的单定时器相同。

```java
final int RELOAD_VAL_SUB = 6;
int timer;
int subTimer;

// 初始化
timer = amount;
subTimer = RELOAD_VAL_SUB;

// 更新
if (timer > 0) {
    if (--subTimer == 0) {
        subTimer = RELOAD_VAL_SUB;
        if (--timer == 0) {
            // 触发事件
        }
    }
}
```

### 带分数

用进位机制还可以模拟分数加减。例如，让一个实体以每帧2/3个像素的速度向右移动，可以这样实现：

```java
int x;
int numer = 0;  // 分子
int denom = 3;  // 分母

// 更新
numer += 2;
if (numer >= demon) {
	numer -= demon;
	x++;
}
```

这种办法相当于把实体的位置存储成了一个带分数。它避免了小数计算，又具有更高的精准度。

如果每帧的增量可能超过1，那么要把上面的if换成while.

上面的例子中分母是固定的，可以定义成常量。但允许分母改变也有它的应用。下面是实现定时炸弹滴滴声的播放“越来越快”效果的一种方案：

```java
int numer = 0;
int demon = 50;

// 更新
if (++numer == demon) {
	numer = 0;
    playBeepSound();
    if (--demon < 5)
    	demon = 5;
}
```
